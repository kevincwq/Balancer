#include <Wire.h> //Include the Wire.h library so we can communicate with the gyro

//#define DEBUG

const unsigned long loop_time = 4000;
unsigned long next_loop_time; //, left_motor_start_time, right_motor_start_time;

// Step motor definition and control
/* The sequence of control signals for 4 control wires is as follows:
 * Step C0 C1 C2 C3
 *    1  1  0  1  0
 *    2  0  1  1  0
 *    3  0  1  0  1
 *    4  1  0  0  1
 */
const uint8_t number_of_steps = 200;
const byte motor_l = 0, motor_r = 1;
const uint16_t step_delay_min = 3000; //60L * 1000L * 1000L / number_of_steps / max_rpm (100);

unsigned long step_delay[2] = {10000, 10000};
unsigned long last_step_time[2];
int left_motor, right_motor, th_left, th_right;
// PD 4~7, PB 0~3
uint8_t motor_pins[2][4] = {{4, 5, 6, 7}, {8, 9, 10, 12}};
int8_t step_number[2] = {0, 0}, step[2] = {0, 0};

void setMotorPins()
{
  DDRD |= B1111000;
  DDRB |= B00001111;
}

void motorPinsOutput(uint8_t thisStep, byte motor)
{
  if (motor == motor_l)
  {
    PORTD &= B00001111;
    switch (thisStep)
    {
    case 0: // 1010
      PORTD |= B01010000;
      break;
    case 1: // 0110
      PORTD |= B01100000;
      break;
    case 2: //0101
      PORTD |= B10100000;
      break;
    case 3: //1001
      PORTD |= B10010000;
      break;
    }
  }
  else if (motor == motor_r)
  {
    PORTB &= B11110000;
    switch (thisStep)
    {
    case 0: // 1010
      PORTB |= B00000101;
      break;
    case 1: // 0110
      PORTB |= B00000110;
      break;
    case 2: //0101
      PORTB |= B00001010;
      break;
    case 3: //1001
      PORTB |= B00001001;
      break;
    }
  }
}


// motor -> motor_l, motor_r
bool stepMotor(uint8_t motor)
{
  unsigned long now = micros();
  // move only if the appropriate delay has passed:
  if (now - last_step_time[motor] >= step_delay[motor])
  {
    if (step[motor] != 0)
    {
      // get the timeStamp of when you stepped:
      last_step_time[motor] = now;
      // increment or decrement the step number,
      // depending on direction:
      if (step[motor] == 1)
      {
        step_number[motor]++;
        if (step_number[motor] == number_of_steps)
        {
          step_number[motor] = 0;
        }
      }
      else
      {
        if (step_number[motor] == 0)
        {
          step_number[motor] = number_of_steps;
        }
        step_number[motor]--;
      }
      motorPinsOutput(step_number[motor] % 4, motor);
    }
    return true;
  }
  return false;
}

// battery related
//Load the battery voltage to the battery_voltage variable.
//diode_voltage_compensation is the voltage compensation for the diode.
//Resistor voltage divider => (2k + 1k)/1k = 3
//15V equals ~5V @ Analog 0.
//15V equals 1023 analogRead(0).
//1500 / 1023 = 1.466.
//The variable battery_voltage holds 1050 if the battery voltage is 10.5V.
const uint16_t battery_low_threshold1 = 1050, battery_high_threshold1 = 800, diode_voltage_compensation = 83;
const unsigned long voltage_loop_time = 5000000;
unsigned long last_voltage_loop_time;
uint16_t battery_voltage;
byte low_bat = 0;

void updateVoltage()
{
  unsigned long t = micros();
  if (t - last_voltage_loop_time > voltage_loop_time)
  {
    battery_voltage = (analogRead(0) * 1.466) + diode_voltage_compensation;
    if (battery_voltage < battery_low_threshold1 && battery_voltage > battery_high_threshold1)
    {                         //If batteryvoltage is below 10.5V and higher than 8.0V
      digitalWrite(13, HIGH); //Turn on the led if battery voltage is too low
      low_bat = 1;            //Set the low_bat variable to 1
#ifdef DEBUG
      Serial.print(F("low battery voltage:"));
      Serial.println(battery_voltage);
#endif
    }
    last_voltage_loop_time = t;
  }
}

// I2C IMU Operation
const int gyro_address = 0x68; //MPU-6050 I2C address (0x68 or 0x69)
// IMU update
const uint8_t calibration_loops = 255;
const int acc_raw_limit = 8200;
uint8_t i2cData[14];                                  // Buffer for I2C data
int gyro_y_data_raw, gyro_x_data_raw, acc_z_data_raw; // pitch, yaw, z
int gyro_y_calib_value = 0, gyro_x_calib_value = 0, acc_z_calib_value = 0;
unsigned long gyro_timer;

/*
3B - ACC_X_H
3C - ACC_X_L
3D - ACC_Y_H
3E - ACC_Y_L
3F - ACC_Z_H
40 - ACC_Z_L
41 - TEMP_H
42 - TEMP_L
43 - GY_X_H
44 - GY_X_L
45 - GY_Y_H
46 - GY_Y_L
47 - GY_Z_H
48 - GY_Z_L
*/

void initIMU()
{
  TWBR = ((F_CPU / 400000L) - 16) / 2; // Set I2C frequency to 400kHz
  Wire.begin();                        //Start the I2C bus as master

  //By default the MPU-6050 sleeps. So we have to wake it up.
  Wire.beginTransmission(gyro_address); //Start communication with the address found during search.
  Wire.write(0x6B);                     //We want to write to the PWR_MGMT_1 register (6B hex)
  Wire.write(0x00);                     //Set the register bits as 00000000 to activate the gyro
  Wire.endTransmission();               //End the transmission with the gyro.
  //Set the full scale of the gyro to +/- 250 degrees per second
  Wire.beginTransmission(gyro_address); //Start communication with the address found during search.
  Wire.write(0x1B);                     //We want to write to the GYRO_CONFIG register (1B hex)
  Wire.write(0x00);                     //Set the register bits as 00000000 (250dps full scale)
  Wire.endTransmission();               //End the transmission with the gyro
  //Set the full scale of the accelerometer to +/- 4g.
  Wire.beginTransmission(gyro_address); //Start communication with the address found during search.
  Wire.write(0x1C);                     //We want to write to the ACCEL_CONFIG register (1A hex)
  Wire.write(0x08);                     //Set the register bits as 00001000 (+/- 4g full scale range)
  Wire.endTransmission();               //End the transmission with the gyro
  //Set some filtering to improve the raw data.
  Wire.beginTransmission(gyro_address); //Start communication with the address found during search
  Wire.write(0x1A);                     //We want to write to the CONFIG register (1A hex)
  Wire.write(0x03);                     //Set the register bits as 00000011 (Set Digital Low Pass Filter to ~43Hz)
  Wire.endTransmission();               //End the transmission with the gyro

  delay(100); // Wait for sensor to stabilize
}

void calibrateIMU()
{
  long gyro_y_calib_sum = 0, gyro_x_calib_sum = 0, acc_z_calib_sum = 0;

  for (uint8_t counter = 0; counter < calibration_loops; counter++)
  {
    //Create calibration_loops loops
    if (counter % 15 == 0)
      digitalWrite(13, !digitalRead(13)); //Change the state of the LED every 15 loops to make the LED blink fast
    updateIMU();
    gyro_y_calib_sum += gyro_y_data_raw;
    gyro_x_calib_sum += gyro_x_data_raw;
    acc_z_calib_sum += acc_z_data_raw;
    delayMicroseconds(loop_time - 300); //Wait for 3700 microseconds to simulate the main program loop time
  }
  gyro_y_calib_value = gyro_y_calib_sum / calibration_loops; //Divide the total value by 500 to get the avarage gyro offset
  gyro_x_calib_value = gyro_x_calib_sum / calibration_loops; //Divide the total value by 500 to get the avarage gyro offset
  acc_z_calib_value = acc_z_calib_sum / calibration_loops;

#ifdef DEBUG
  Serial.print(F("gyro_y_calib:"));
  Serial.println(gyro_y_calib_value);
  Serial.print(F("gyro_x_calib:"));
  Serial.println(gyro_x_calib_value);
  Serial.print(F("acc_z_calib:"));
  Serial.println(acc_z_calib_value);
#endif
}

void updateIMU()
{
  Wire.beginTransmission(gyro_address); //Start communication with the gyro
  Wire.write(0x3F);                     //Start reading at register 3F
  Wire.endTransmission();               //End the transmission
  Wire.requestFrom(gyro_address, 2);    //Request 2 bytes from the gyro
  //Prevent division by zero by limiting the acc data to +/-acc_raw_limit;
  acc_z_data_raw = constrain((Wire.read() << 8 | Wire.read()) + acc_z_calib_value, -acc_raw_limit, acc_raw_limit);

  Wire.beginTransmission(gyro_address); //Start communication with the gyro
  Wire.write(0x43);                     //Start reading at register 43
  Wire.endTransmission();               //End the transmission
  Wire.requestFrom(gyro_address, 4);    //Request 4 bytes from the gyro
  gyro_x_data_raw = ((Wire.read() << 8) | Wire.read()) - gyro_x_calib_value;
  gyro_y_data_raw = ((Wire.read() << 8) | Wire.read()) - gyro_y_calib_value;

  // #ifdef DEBUG
  //   Serial.print(F("calib_acc_z: "));
  //   Serial.println(acc_z_calib_value);
  //   Serial.print(F("calib_gyro_x: "));
  //   Serial.println(gyro_x_calib_value);
  //   Serial.print(F("calib_gyro_y: "));
  //   Serial.println(gyro_y_calib_value);
  // #endif
}

//Various settings
const float pid_p_gain = 15;        //Gain setting for the P-controller (15)
const float pid_i_gain = 1.5;       //Gain setting for the I-controller (1.5)
const float pid_d_gain = 30;        //Gain setting for the D-controller (30)
const float turning_speed = 30;     //Turning speed (20)
const float max_target_speed = 150; //Max target speed (100)
const int dead_band = 5;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Declaring global variables
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
byte start, received_byte;
int receive_counter;

float angle_gyro, angle_acc, angle, self_balance_pid_setpoint;
float pid_error_temp, pid_i_mem, pid_setpoint, gyro_input, pid_output, pid_last_d_error;
float pid_output_left, pid_output_right;

void calcAngle()
{
  angle_acc = asin((float)acc_z_data_raw / acc_raw_limit) * 57.296; //Calculate the current angle according to the accelerometer

#ifdef DEBUG
  Serial.print(F("acc ang:"));
  Serial.println(angle_acc);
#endif

  if (start == 0 && angle_acc > -0.5 && angle_acc < 0.5)
  {
    //If the accelerometer angle is almost 0
    angle_gyro = angle_acc; //Load the accelerometer angle in the angle_gyro variable
    start = 1;              //Set the start variable to start the PID controller
  }

  // 500°/s / 2^16 * loop_time = 0.00762939453125 * loop_time
  angle_gyro += gyro_y_data_raw * 0.0076294 * (micros() - gyro_timer) / 1000000.0; //Calculate the traveled during this loop angle and add this to the angle_gyro variable
  gyro_timer = micros();

#ifdef DEBUG
  Serial.print(F("gyro ang:"));
  Serial.println(angle_gyro);
#endif

  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //MPU-6050 offset compensation
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //Not every gyro is mounted 100% level with the axis of the robot.
  //This can be caused by misalignments during manufacturing of the breakout board.
  //As a result the robot will not rotate at the exact same spot and start to make larger and larger circles.
  //To compensate for this behavior a VERY SMALL angle compensation is needed when the robot is rotating.
  //Try 0.0000003 or -0.0000003 first to see if there is any improvement.

  //Uncomment the following line to make the compensation active
  //angle_gyro -= gyro_x_data_raw * 0.0000003;                            //Compensate the gyro offset when the robot is rotating

  angle_gyro = angle_gyro * 0.9996 + angle_acc * 0.0004; //Correct the drift of the gyro angle with the accelerometer angle

#ifdef DEBUG
  Serial.print(F("comp ang:"));
  Serial.println(angle_gyro);
#endif
}

void controlProcess()
{
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //Control calculations
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  if (Serial.available())
  {                                //If there is serial data available
    received_byte = Serial.read(); //Load the received serial data in the received_byte variable
    receive_counter = 0;           //Reset the receive_counter variable
  }
  if (receive_counter <= 25)
    receive_counter++; //The received byte will be valid for 25 program loops (100 milliseconds)
  else
    received_byte = 0x00; //After 100 (25 * loop_time) milliseconds the received byte is deleted

  pid_output_left = pid_output;  //Copy the controller output to the pid_output_left variable for the left motor
  pid_output_right = pid_output; //Copy the controller output to the pid_output_right variable for the right motor

  if (received_byte & B00000001)
  {                                    //If the first bit of the receive byte is set change the left and right variable to turn the robot to the left
    pid_output_left += turning_speed;  //Increase the left motor speed
    pid_output_right -= turning_speed; //Decrease the right motor speed
  }
  if (received_byte & B00000010)
  {                                    //If the second bit of the receive byte is set change the left and right variable to turn the robot to the right
    pid_output_left -= turning_speed;  //Decrease the left motor speed
    pid_output_right += turning_speed; //Increase the right motor speed
  }

  if (received_byte & B00000100)
  { //If the third bit of the receive byte is set change the left and right variable to turn the robot to the right
    if (pid_setpoint > -2.5)
      pid_setpoint -= 0.05; //Slowly change the setpoint angle so the robot starts leaning forewards
    if (pid_output > max_target_speed * -1)
      pid_setpoint -= 0.005; //Slowly change the setpoint angle so the robot starts leaning forewards
  }
  if (received_byte & B00001000)
  { //If the forth bit of the receive byte is set change the left and right variable to turn the robot to the right
    if (pid_setpoint < 2.5)
      pid_setpoint += 0.05; //Slowly change the setpoint angle so the robot starts leaning backwards
    if (pid_output < max_target_speed)
      pid_setpoint += 0.005; //Slowly change the setpoint angle so the robot starts leaning backwards
  }

  if (!(received_byte & B00001100))
  { //Slowly reduce the setpoint to zero if no foreward or backward command is given
    if (pid_setpoint > 0.5)
      pid_setpoint -= 0.05; //If the PID setpoint is larger then 0.5 reduce the setpoint with 0.05 every loop
    else if (pid_setpoint < -0.5)
      pid_setpoint += 0.05; //If the PID setpoint is smaller then -0.5 increase the setpoint with 0.05 every loop
    else
      pid_setpoint = 0; //If the PID setpoint is smaller then 0.5 or larger then -0.5 set the setpoint to 0
  }

  //The self balancing point is adjusted when there is not forward or backwards movement from the transmitter.
  //This way the robot will always find it's balancing point
  if (pid_setpoint == 0)
  { //If the setpoint is zero degrees
    if (pid_output < 0)
      self_balance_pid_setpoint += 0.0015; //Increase the self_balance_pid_setpoint if the robot is still moving forewards
    if (pid_output > 0)
      self_balance_pid_setpoint -= 0.0015; //Decrease the self_balance_pid_setpoint if the robot is still moving backwards
  }
}

void calcPid()
{
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //PID controller calculations
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //The balancing robot is angle driven. First the difference between the desired angel (setpoint) and actual angle (process value)
  //is calculated. The self_balance_pid_setpoint variable is automatically changed to make sure that the robot stays balanced all the time.
  //The (pid_setpoint - pid_output * 0.015) part functions as a brake function.
  pid_error_temp = angle_gyro - self_balance_pid_setpoint - pid_setpoint;
  if (pid_output > 10 || pid_output < -10)
    pid_error_temp += pid_output * 0.015;

  pid_i_mem += pid_i_gain * pid_error_temp;    //Calculate the I-controller value and add it to the pid_i_mem variable
  pid_i_mem = constrain(pid_i_mem, -400, 400); //Limit the I-controller to the maximum controller output

  //Calculate the PID output value
  pid_output = pid_p_gain * pid_error_temp + pid_i_mem + pid_d_gain * (pid_error_temp - pid_last_d_error);
  pid_output = constrain(pid_output, -400, 400); //Limit the PI-controller to the maximum controller output

  pid_last_d_error = pid_error_temp; //Store the error for the next loop

  if (pid_output < dead_band && pid_output > -dead_band)
    pid_output = 0; //Create a dead-band to stop the motors when the robot is balanced

  if (angle_gyro > 30 || angle_gyro < -30 || start == 0 || low_bat == 1)
  {                                //If the robot tips over or the start variable is zero or the battery is empty
    pid_output = 0;                //Set the PID controller output to 0 so the motors stop moving
    pid_i_mem = 0;                 //Reset the I-controller memory
    start = 0;                     //Set the start variable to 0
    self_balance_pid_setpoint = 0; //Reset the self_balance_pid_setpoint variable
  }
}

void calcStepDelay()
{
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //Motor pulse calculations
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //To compensate for the non-linear behaviour of the stepper motors the folowing calculations are needed to get a linear speed behaviour.
  if (pid_output_left > 0)
    pid_output_left = 405 - (1 / (pid_output_left + 9)) * 5500;
  else if (pid_output_left < 0)
    pid_output_left = -405 - (1 / (pid_output_left - 9)) * 5500;

  if (pid_output_right > 0)
    pid_output_right = 405 - (1 / (pid_output_right + 9)) * 5500;
  else if (pid_output_right < 0)
    pid_output_right = -405 - (1 / (pid_output_right - 9)) * 5500;

  //Calculate the needed pulse time for the left and right stepper motor controllers
  if (pid_output_left > 0)
    left_motor = 400 - pid_output_left;
  else if (pid_output_left < 0)
    left_motor = -400 - pid_output_left;
  else
    left_motor = 0;

  if (pid_output_right > 0)
    right_motor = 400 - pid_output_right;
  else if (pid_output_right < 0)
    right_motor = -400 - pid_output_right;
  else
    right_motor = 0;

  th_left = left_motor;
  th_right = right_motor;

#ifdef DEBUG
  Serial.print(F("l_th:"));
  Serial.println(left_motor);
  Serial.print(F("r_th:"));
  Serial.println(right_motor);
#endif
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Setup basic functions
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void setup()
{
  pinMode(13, OUTPUT); //Configure digital poort 13 as output
  setMotorPins();

  Serial.begin(115200);
  initIMU();
  calibrateIMU();
  next_loop_time = micros() + loop_time;
  gyro_timer = micros();

  //set timer1 interrupt at 1Hz
  TCCR1A = 0; // set entire TCCR1A register to 0
  TCCR1B = 0; // same for TCCR1B
  TCNT1 = 0;  //initialize counter value to 0
  // set compare match register for 1hz increments
  OCR1A = 156; // = (16*10^6) / (1*1024) - 1 (must be <65536)
  // turn on CTC mode
  TCCR1B |= (1 << WGM12);
  // Set CS10 and CS12 bits for 1024 prescaler
  TCCR1B |= (1 << CS12) | (1 << CS10);
  // enable timer compare interrupt
  TIMSK1 |= (1 << OCIE1A);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Main program loop
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void loop()
{
  // Serial.println(F("main loop"));
  if (stepMotor(motor_l))
  {
    //Copy the pulse time to the throttle variables so the interrupt subroutine can use them
    int temp = th_left;
    if (temp > 0)
      step[motor_l] = -1;
    else if (temp < 0)
      step[motor_l] = 1;
    else
      step[motor_l] = 0;
    // step_delay[motor_l] = max(abs(temp) * 8, step_delay_min);
    step_delay[motor_l] = abs(temp) * 20 * 10;
#ifdef DEBUG
    Serial.print(F("l: "));
    Serial.println(step[motor_l]);
#endif
  }
  if (stepMotor(motor_r))
  {
    int temp = th_right;
    if (temp > 0)
      step[motor_r] = 1;
    else if (temp < 0)
      step[motor_r] = -1;
    else
      step[motor_r] = 0;

    // step_delay[motor_r] = max(abs(temp) * 8, step_delay_min);
    step_delay[motor_r] = abs(temp) * 20 * 10;
#ifdef DEBUG
    Serial.print(F(" r: "));
    Serial.println(step[motor_r]);
#endif
  }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Interrupt routine  TIMER2_COMPA_vect
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ISR(TIMER1_COMPA_vect)
{
  sei();
  updateVoltage();
  updateIMU();
  calcAngle();
  calcPid();
  controlProcess();
  calcStepDelay();
}